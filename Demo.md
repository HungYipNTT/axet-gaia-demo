# Scenario 
- Revamp a legacy ordering system for a UK-based sports fashion retailer
- We are the backend team and are going to implement customer, order, and product entities with SpringBoot and JPA

# How to apply Gaia in the development life cycle
## Design: 
- Analyze the existing design directly from the legacy system URLs
  - Customer form: https://hungyipntt.github.io/axet-gaia-demo/forms/customer-ref-form.html
  - Order form: https://hungyipntt.github.io/axet-gaia-demo/forms/order-form.html
- Prepare the UML class diagram for the entity classes
## Development:
- Create the JPA entity classes based on the design, new requirements, and client's best practise
- Create the CRUD repository using Native SQL for search
- Create the Postgres DB tables for the entity classes
## Testing:
- Generate volume of testing data

# Client's best practice:
- All JPA entity classes should extend from an abstract audit classes, which have the audit fields:
  - createdBy, createDate, lastUpdBy, lastUpdDate, ver
- Use Lombok for POJO to prevent boilerplate code of Getter/Setter methods
- Primary key for DB tables should be a LONG type with and autogenerated key

# Requirement
- Redesign the product page and taking references from their competitors
- Introduce the discount feature for the new order form
- For data migration, keep the field names from the original forms while naming the entity class properties  
- Provide the native SQL in the CRUD repository since the  development team is not familiar with it 

# Demo

# Furthermore from Gaia:
## Design:
- Automate the analysis scraping client's Confluence, JIRA, Sharepoint, and documents with Agent or RAG
## Development:
- Extend the code generation to front-end, devOps... 
## Testing:
- Generate test cases
- Code review
## Deployment:
- Prepare the release notes by summarizing JIRA, or other ticketing system
